

指针和引用的区别1.定义方式
  指针是一个变量，存储的是另一个变量的内存地址；
  引用是某个已存在的变量的别名，必须在声明时初始化，并且不能更改其引用的对象
2.初始化要求
  指针可以不初始化或者被赋值为nullptr；
  引用必须在声明时初始化，并且一旦绑定到某个对象后，不能更改引用的对象
3.是否可变
  指针本身是可以改变的，它可以指向不同的对象；
  引用一旦绑定到某个对象后，就不能再改变引用的对象
4.内存占用
  指针本身占用一定的内存空间（通常为4字节或8字节，取决于系统架构）
  引用本质上是编译器的一种语法糖，不额外占用内存空间（实际上引用在底层实现上可能通过指针来实现，但这对程序员透明）
5.空值处理
  指针可以为nullptr，表示它不指向任何有效的对象
  引用不能为nullptr，也不能为空。引用必须始终绑定到一个有效的对象
6.传递参数时的行为
  可以通过指针传递参数，并且可以通过指针修改调用者的变量
  引用也可以修改调用者的变量，但更简洁，不易出错
7.数组和函数返回值
  指针可以返回局部数组的指针，但要注意返回局部变量的地址会导致悬空指针问题
  引用不能直接返回局部数组的引用，因为局部变量会在函数结束后被销毁
总结
  指针更灵活，可以动态的指向不同的对象，支持空值$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$98287b2d-a3bc-436c-b5ee-930b5412877d

1结构体struct和共同体union(联合)的区别1.内存分配
  结构体为每个成员变量分配独立的内存空间，总大小等于所有成员变量占用的空间之和（考虑字节对齐的情况下可能更大）
  共同体的所有成员变量共享一块内存空间，总大小等于其最大成员变量所占用的空间（同样考虑字节对齐）
2.成员变量的访问
  结构体可以同时访问所有的成员变量，每个成员变量有自己独立的地址，互不干扰
  共同体同一时刻只能有一个成员变量有效，因为它们共享同一块内存，访问一个成员会覆盖其它成员的数据
3.使用场景
  结构体用于需要存储多个不同类型或相同类型的值，并且这些值需要同时存在
  共同体用于需要节省内存，并且同一时刻只需要存储其中一个成员变量
总结：
  结构体适用于需要同时存储多个不同或相同类型的值的情况
  共同体适用于需要节省内存并且同一时刻只存储一个值的情况$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$658846cf-d700-463a-a089-e52005cc6402
e
define和const的区别$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$fe20e6ac-5ef3-4340-b4bf-fa875138ea65
y
+new、delete、malloc、free之间的关系$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$3b34e1f2-82e2-4038-932d-f0565e064212
h
delete和delete[]的区别$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$25e22b23-2b66-43fa-bcc4-503563216e07
f
关键字static的作用$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$683f5fe4-6db6-44e2-b516-cf4a24b986e8
z
,#include <file.h>和#include "file"的区别$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$6b3bcb61-c20a-4878-a0e0-7b712eb62e35
f
定义和声明的区别$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$07a91cfc-6bd5-4765-a78a-d717df017776
`
内存管理机制$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$863fa164-941e-4316-938c-57c297910c8f

c构造函数为什么一般不定义为虚函数？而析构函数一般写成虚函数的原因？$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$f25788b4-2f8b-4b82-9539-e4959131785f
i
静态绑定和动态绑定$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$1beb16e6-04f3-4c09-ba16-868edb9ecc50

6引用能够实现动态绑定，为什么可以实现$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$49462316-3a5b-489a-8734-daa6408c38b9
o
!浅拷贝与深拷贝详细阐述$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$44983185-4738-4fd8-9bd1-d570ed9fb88c
`
四种强制转换$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$35fd8497-8b62-4efa-b5a7-67c25e0c4d0d
a
extern "C"的作用$ad4e0c05-a58f-4bcc-be6d-38d1af061419"$39e738d4-d7b1-4eca-a2cb-9e643c157e47